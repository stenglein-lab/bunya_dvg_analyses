library (stringr)
library (dplyr)
library (ggplot2)
library (gridExtra)
library (cowplot)

# This script reads in coverage and DVG data and does some pre-processing on it
#
# Mark Stenglein Mar 2, 2019

print(paste0("importing and tidying DVG data..."))

# ------------------------
# import read depth info.   
#
# Depth of coverage for all segments at all positions.
#
# all.depth was created by running this command (in mdstengl@cctsi-104:~/datasets/bunyas/all_sequences_1_11_19)
# individual depth files were created using samtools depth
#
# cat *.depth > all.depth
# cp all.depth ../bunya_dvg_analyses/data
#
# ------------------------
depth_df <- read.delim("../data/all.depth", sep="\t", header=FALSE)
colnames(depth_df) <- c("segment", "position", "depth")

#  -----------------------------
#  Import 'Split' read coverage
#
#  that is, the coverage of 'split reads' identified by DI-tector that map across deletion DVG breakpoints
#  note that other types of DVGs are not included in this file
#  -----------------------------------------------------------
#
#  this input file was generated by the following bash commands (in mdstengl@cctsi-104:~/datasets/bunyas/dip)
#
#  find . -name DI_output_sorted.txt  -exec grep 'Deletion' {} \;    > all_di_output_sorted.txt
#  ./tabulate_split_coverage < all_di_output_sorted.txt  > all_split_read_coverage.txt
#  cp all_split_read_coverage.txt ../bunya_dvg_analyses/data
#
split_cov_df <- read.delim("../data/all_split_read_coverage.txt", sep="\t", header=T)


# set 0 coverage values to 1 (since plotting on a log scale)
split_cov_df[split_cov_df$split_depth == 0, "split_depth"] <- 1

# join split read cov w/ main depth table
# will join by shared columns segment & position
combined_depth_df <- left_join(depth_df, split_cov_df)

# this creates a new column named virus that is determined by stripping the _S, _M, or _L off of the segment name
combined_depth_df$virus <- str_match(combined_depth_df$segment, "(\\S+)_[SML]{1}?")[,2]

# this creates a new column named seg that is either S, M, or L (last character of segment name)
combined_depth_df$seg <- as.factor(str_sub(combined_depth_df$segment, start=-1))

# positions with some coverage but no split read cov will have split_depth of NA, convert to 1
combined_depth_df$split_depth[is.na(combined_depth_df$split_depth)] <- 1

# filter out positions with <5x coverage
# combined_depth_df$split_depth[combined_depth_df$split_depth < 5 ] <- 1

# this step filters out segments with a peak split read mapping depth of less than 5 split reads
#
# creates a (temporarily used) dataframe with those segments that have a maximum split coverage > 5
sufficient_split_cov <- combined_depth_df %>% 
group_by(segment) %>% 
summarize(split_cov_peak = max(split_depth))  %>%
filter(split_cov_peak > 5)

# this filters that main df based on the temporary df
combined_depth_df <- combined_depth_df %>% filter(segment %in% sufficient_split_cov$segment)

# ------------------------------
# Import DI-tect quantified DVGs
# ------------------------------
# read DI-tect output of deletion breakpoint split-mapped reads.
#
# this file di_counts.txt was generated by running these commands:
#
# mdstengl@cctsi-104:~/datasets/bunyas/dip$  simple_scheduler -a 4 ./run_di `cat virus_names.txt`
# mdstengl@cctsi-104:~/datasets/bunyas/dip$  ./collect_di_counts
# mdstengl@cctsi-104:~/datasets/bunyas/dip$  cp di_counts.txt ../bunya_dvg_analyses/data
#
# reads in the tab-delimited file
di_df <- read.delim("../data/di_counts.txt", sep="\t", header=FALSE)
# name the columns, since unnamed in the file
colnames(di_df) <- c("type", "length", "bp", "ri", "delta", "ref", "counts", "pct_to_virus") 

# parse out segment (S/M/L), segment name, and virus name
di_df$seg <- as.factor(str_sub(di_df$ref, start=-1))
di_df$segment <- str_extract(di_df$ref, "(\\S+)\\|") %>% str_replace("\\|","")
di_df$virus <- str_match(di_df$segment, "(\\S+)_[SML]")[,2]

# this will plot the # of different types of DVGs (deletion, cb, etc.)
counts_summary <- di_df %>% group_by(segment, type) %>% summarize(counts = sum(counts))
ggplot(data=counts_summary, aes(y=counts, x=type)) + geom_point()

# filter to create dataframes with only particular types of DVGs 
del_df <- filter(di_df, type=="Deletion DVG (Fwd. strand)") 
sb3_df <- filter(di_df, type=="3' cb/sb DVG") 
sb5_df <- filter(di_df, type=="5' cb/sb DVG") 
ins_df <- filter(di_df, type=="Insertion DVG") 

# filter only breakpoints with >N supporting reads
# note this is a paramter option when running DI-tector from the command line too
min_reads_over_breakpoint <- 3
del_df <- filter(del_df, counts >= min_reads_over_breakpoint) 

# how many of each segment type have deletion DVGs supported by enough unique reads
num_dvg <- nrow(del_df %>% filter(counts >= min_reads_over_breakpoint))
num_dvg

# how many S, M, L segments have enough unique reads
del_count <- del_df %>% filter(counts >= min_reads_over_breakpoint) %>% group_by(segment, seg) %>% summarize (n=n()) %>% group_by(seg) %>% summarize(n=n())
del_count

# this could be used to filter out shorter deletions
# del_df %>% filter(abs(bp-ri) < 100)

# this calculates distance from 3' end (of deletion breakpoint)
# based on length of deleted molecule and bp, which is distance from 5' end 
del_df <- del_df %>% mutate(dist_3p_end = length - bp - 1)
  
